{
  "name": "Arnolyzer",
  "tagline": "Clean-code Roslyn-based analyzer for C# 6",
  "body": "# Arnolyzer\r\nA clean-code, Roslyn-based, analyzer for C# 6.\r\n\r\nReadme last updated: 28th Mar 2016.\r\n\r\n\r\nIts aims are simple: provide a set of rules that encourage modern, functional-orientated, coding standards in C#. Pure functions, no inheritance, no global state, immutable variables and short, concise sections of code.\r\n   \r\n## What's implemented\r\nThus far, the analyzers implemented are:\r\n\r\n**[AA1000 - Static Methods Should Not Be Void](Arnolyzer/Documentation/AA1000StaticMethodsShouldNotBeVoidAnalyzer.md)**\r\n\r\n\r\n## What's planned\r\nThe following planned analyzers haven't yet been implemented:\r\n\r\n**ClassesMustBeSealed**\r\n\r\n**DoNotUseAbstractClasses**\r\n\r\n**DoNotUseClassInheritance**\r\n\r\n**DoNotUseStaticFields**\r\n\r\n**DoNotUseStaticProperties**\r\n\r\n**FileTooLong**\r\n\r\n**MethodTooLong**\r\n\r\n**StaticMethodMustNotAccessState**\r\n\r\n**StaticMethodMustNotCreateState**\r\n\r\n**ParameterShouldNotBeModified**\r\n\r\n**VariableShouldBeAssignedOnce**\r\n\r\nFor details of each of these, please see the descriptions below.\r\n\r\nIn addition, there are situations where some of these rules can legitimately be suppressed with attributes and where code fixes can be used to apply those attributes. This also is a largely \"not yet done\" topic.\r\n\r\n## Analyzer descriptions\r\n\r\n### Static higher order functions (SHOFs)\r\nStatic methods that create or access global state are well recognised as code smells: they create thread-unsafe units of code with tight coupling and they make unit testing harder than it need be. Functional languages though also have static functions, called higher order (or pure) functions. These functions are completely deterministic and are well recognised as a way of avoiding coupling, simplifying testing and for creating thread-safe code.\r\n\r\nTo distinguish between stateful static methods and methods that copy the principles of higher order functions, [Mike Hadlow](https://twitter.com/mikehadlow/status/646645950656708608) coined the term Static Higher Order Function (SHOF) to identify the latter in OO languages, such as C#.\r\n\r\n#### AA1000 Static Methods Must Not Be Void\r\nTo count as a SHOF, a static method must have no side effects, and thus to have a purpose, it must return a value.\r\n\r\n#### AA1001 Static Methods Must Have At Least One Parameter\r\nTo count as a SHOF, a static method must not receive data from any source other than its parameters, thus it must have at least one parameter to have a purpose.\r\n\r\n#### AA1002 Static Methods Must Not Access State\r\nA SHOF must only derive a result from the supplied parameter(s). It must not access any static field or property.\r\n\r\n#### AA1003 Static Methods Must Not Create State\r\nThe only result from calling a SHOF must be the returned value, or an exception. Therefore it must not invoke any method that has a void return type, nor write to any field or property.\r\n\r\n### Immutability and Encapsulation\r\nA badly named variable that has many values written to it over the course of a long-winded method makes for hard-to-read code. Variables that only written to once both make for easier reading, as a new appropriately named variable must be created for each assignment, and encourage the principle of least surprise. The following rules enforce that idea:\r\n\r\n#### AA1100 - Parameters Should Not Be Modified\r\nReports when a parameter is used as a mutable variable.\r\n\r\n#### AA1101 - Variables Should Be Assigned Once\r\nReports when a variable is re-assigned.\r\n\r\n#### AA1102 - Interface Properties Must Be Read-Only\r\nProperties defined by interfaces should not have setters.\r\n\r\n#### AA1103 - Class Properties Must Be Publicly Read-Only\r\nClass properties should not have public setters.\r\n\r\n#### AA1104 - Inner Types Must Be Private\r\nInner types should not be marked `internal` or `public` as this leads to leaky abstractions.\r\n\r\n###No global/static state\r\nGlobal (and to a lesser extent, any static) state creates a testing and maintenance nightmare as code becomes both tightly coupled and tests must be run in sequence through fear that two tests might call two pieces of code that both modify shared state resulting in brittle tests. These rules prevent global and static state:\r\n\r\n#### AA1200 Do Not Use Static Fields\r\nStatic fields contain static scope and so should be avoided.\r\n\r\n#### AA1201 Do Not Use Static Properties\r\nStatic properties contain static scope and so should be avoided.\r\n\r\n###Liskov Substitution Principle\r\nFrom the [Liskov Substitution Principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle) article on Wikipedia:\r\n> Substitutability is a principle in object-oriented programming. It states that, in a computer program, if S is a subtype of T, then objects of type T may be replaced with objects of type S (i.e., objects of type S may substitute objects of type T) without altering any of the desirable properties of that program (correctness, task performed, etc.)\r\n\r\nTwo exceptions defined by the .NET framework are a direct violation of this principle (LSP) and the following two rules check for such violations:\r\n\r\n#### AA2000 Do Not Use NotImplementedException\r\nNotImplementedException violates LSP and should not be used.\r\n\r\n#### AA2001 Do Not Use NotSupportedException\r\nNotSupportedException violates LSP and should not be used.\r\n\r\n###Single responsibility principle\r\nThe [single responsibility principle](https://en.wikipedia.org/wiki/Single_responsibility_principle) article on Wikipedia states:\r\n> the single responsibility principle states that every class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class. All its services should be narrowly aligned with that responsibility\r\n\r\nThe following rules extend this principle to methods and files and seek to identify sections of code that may break that principle:\r\n\r\n#### AA2100 Method Parameters Must Not Be Ref Or Out\r\nReports when either `ref` or `out` are used for any parameter of any method. Both of these keywords lead to a method that returns two results via two different routes, breaking the single responsibility principle.\r\n\r\n#### AA2101 Method Too Long\r\nA long method is likely to break the principle by carrying out too many functions. What is too long is highly subjective, so this rule will need to be configurable to allow the maximum lines to be specified.\r\n\r\n#### AA2102 File Too Long\r\nA long class is likely to break the principle by carrying out too many functions. What is too long is highly subjective, so this rule will need to be configurable to allow the maximum lines to be specified.\r\n\r\n#### AA2103 Method Should Not Contain And\r\nMethods that contain \"And\" in their name often undertake two tasks and thus have two responsibilities. Thus they are likely to violate the principle.\r\n\r\n#### AA2104 File Must Only Contain One Type Definition\r\nA file that contains more than one class, enum or interface definition inherently contains more than one responsibility.  ",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}