using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Arnolyzer.Analyzers.Settings;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using SuccincT.Options;

namespace Arnolyzer.Analyzers
{
    internal static class CommonFunctions
    {
        public static string SeverityType(this DiagnosticSeverity severity) => Enum.GetName(typeof(DiagnosticSeverity), severity);

        public static bool IsEnabledByDefault(this DefaultState state) => state == DefaultState.EnabledByDefault;

        public static bool AutoGenerated(ISymbol symbol)
        {
            var syntaxRoot = symbol.DeclaringSyntaxReferences[0].SyntaxTree.GetRoot();
            return syntaxRoot.ChildNodes()
                             .Where(n => n.HasLeadingTrivia)
                             .Any(node => node.GetLeadingTrivia().Any(t => t.ToString().Contains("<auto-generated>")));
        }

        public static bool HasIgnoreRuleAttribute(ISymbol symbol, IEnumerable<Type> attributes) => 
            symbol.GetAttributes()
                  .Any(s => attributes.FirstOrNone(t => MatchAttributeName(t, s.AttributeClass.Name)).HasValue);

        public static bool PropertyHasIgnoreRuleAttribute(PropertyDeclarationSyntax property,
                                                          IEnumerable<Type> attributes) =>
                property.AttributeLists
                    .SelectMany(l => l.Attributes, (l, a) => a.Name.GetText().ToString())
                    .Any(name => attributes.FirstOrNone(t => MatchAttributeName(t, name)).HasValue);

        public static bool IgnoredFile(ISymbol symbol)
        {
            var syntaxTree = symbol.DeclaringSyntaxReferences[0].SyntaxTree;
            var options = syntaxTree.ArnolyzerSettings();
            return options.IgnorePathsRegex != "" && Regex.Match(syntaxTree.FilePath, options.IgnorePathsRegex).Success;
        }

        public static bool NodeIsTypeDeclaration(SyntaxNode node)
        {
            var kind = node?.Kind();
            return kind == SyntaxKind.ClassDeclaration ||
                   kind == SyntaxKind.InterfaceDeclaration ||
                   kind == SyntaxKind.StructDeclaration ||
                   kind == SyntaxKind.EnumDeclaration;
        }

        private static bool MatchAttributeName(Type attributeType, string name) =>
            attributeType.Name.Replace("Attribute", "") == name || attributeType.Name == name;
    }
}