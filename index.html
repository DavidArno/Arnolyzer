<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Arnolyzer : Clean-code Roslyn-based analyzer for C# 6">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Arnolyzer</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/DavidArno/Arnolyzer">View on GitHub</a>

          <h1 id="project_title">Arnolyzer</h1>
          <h2 id="project_tagline">Clean-code Roslyn-based analyzer for C# 6</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/DavidArno/Arnolyzer/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/DavidArno/Arnolyzer/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a id="arnolyzer" class="anchor" href="#arnolyzer" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Arnolyzer</h1>

<p>A clean-code, Roslyn-based, analyzer for C# 6.</p>

<p>Readme last updated: 28th Mar 2016.</p>

<p>Its aims are simple: provide a set of rules that encourage modern, functional-orientated, coding standards in C#. Pure functions, no inheritance, no global state, immutable variables and short, concise sections of code.</p>

<h2>
<a id="whats-implemented" class="anchor" href="#whats-implemented" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>What's implemented</h2>

<p>Thus far, the analyzers implemented are:</p>

<p><strong><a href="Arnolyzer/Documentation/AA1000StaticMethodsShouldNotBeVoidAnalyzer.md">AA1000 - Static Methods Should Not Be Void</a></strong></p>

<h2>
<a id="whats-planned" class="anchor" href="#whats-planned" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>What's planned</h2>

<p>The following planned analyzers haven't yet been implemented:</p>

<p><strong>ClassesMustBeSealed</strong></p>

<p><strong>DoNotUseAbstractClasses</strong></p>

<p><strong>DoNotUseClassInheritance</strong></p>

<p><strong>DoNotUseStaticFields</strong></p>

<p><strong>DoNotUseStaticProperties</strong></p>

<p><strong>FileTooLong</strong></p>

<p><strong>MethodTooLong</strong></p>

<p><strong>StaticMethodMustNotAccessState</strong></p>

<p><strong>StaticMethodMustNotCreateState</strong></p>

<p><strong>ParameterShouldNotBeModified</strong></p>

<p><strong>VariableShouldBeAssignedOnce</strong></p>

<p>For details of each of these, please see the descriptions below.</p>

<p>In addition, there are situations where some of these rules can legitimately be suppressed with attributes and where code fixes can be used to apply those attributes. This also is a largely "not yet done" topic.</p>

<h2>
<a id="analyzer-descriptions" class="anchor" href="#analyzer-descriptions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Analyzer descriptions</h2>

<h3>
<a id="static-higher-order-functions-shofs" class="anchor" href="#static-higher-order-functions-shofs" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Static higher order functions (SHOFs)</h3>

<p>Static methods that create or access global state are well recognised as code smells: they create thread-unsafe units of code with tight coupling and they make unit testing harder than it need be. Functional languages though also have static functions, called higher order (or pure) functions. These functions are completely deterministic and are well recognised as a way of avoiding coupling, simplifying testing and for creating thread-safe code.</p>

<p>To distinguish between stateful static methods and methods that copy the principles of higher order functions, <a href="https://twitter.com/mikehadlow/status/646645950656708608">Mike Hadlow</a> coined the term Static Higher Order Function (SHOF) to identify the latter in OO languages, such as C#.</p>

<h4>
<a id="aa1000-static-methods-must-not-be-void" class="anchor" href="#aa1000-static-methods-must-not-be-void" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AA1000 Static Methods Must Not Be Void</h4>

<p>To count as a SHOF, a static method must have no side effects, and thus to have a purpose, it must return a value.</p>

<h4>
<a id="aa1001-static-methods-must-have-at-least-one-parameter" class="anchor" href="#aa1001-static-methods-must-have-at-least-one-parameter" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AA1001 Static Methods Must Have At Least One Parameter</h4>

<p>To count as a SHOF, a static method must not receive data from any source other than its parameters, thus it must have at least one parameter to have a purpose.</p>

<h4>
<a id="aa1002-static-methods-must-not-access-state" class="anchor" href="#aa1002-static-methods-must-not-access-state" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AA1002 Static Methods Must Not Access State</h4>

<p>A SHOF must only derive a result from the supplied parameter(s). It must not access any static field or property.</p>

<h4>
<a id="aa1003-static-methods-must-not-create-state" class="anchor" href="#aa1003-static-methods-must-not-create-state" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AA1003 Static Methods Must Not Create State</h4>

<p>The only result from calling a SHOF must be the returned value, or an exception. Therefore it must not invoke any method that has a void return type, nor write to any field or property.</p>

<h3>
<a id="immutability-and-encapsulation" class="anchor" href="#immutability-and-encapsulation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Immutability and Encapsulation</h3>

<p>A badly named variable that has many values written to it over the course of a long-winded method makes for hard-to-read code. Variables that only written to once both make for easier reading, as a new appropriately named variable must be created for each assignment, and encourage the principle of least surprise. The following rules enforce that idea:</p>

<h4>
<a id="aa1100---parameters-should-not-be-modified" class="anchor" href="#aa1100---parameters-should-not-be-modified" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AA1100 - Parameters Should Not Be Modified</h4>

<p>Reports when a parameter is used as a mutable variable.</p>

<h4>
<a id="aa1101---variables-should-be-assigned-once" class="anchor" href="#aa1101---variables-should-be-assigned-once" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AA1101 - Variables Should Be Assigned Once</h4>

<p>Reports when a variable is re-assigned.</p>

<h4>
<a id="aa1102---interface-properties-must-be-read-only" class="anchor" href="#aa1102---interface-properties-must-be-read-only" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AA1102 - Interface Properties Must Be Read-Only</h4>

<p>Properties defined by interfaces should not have setters.</p>

<h4>
<a id="aa1103---class-properties-must-be-publicly-read-only" class="anchor" href="#aa1103---class-properties-must-be-publicly-read-only" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AA1103 - Class Properties Must Be Publicly Read-Only</h4>

<p>Class properties should not have public setters.</p>

<h4>
<a id="aa1104---inner-types-must-be-private" class="anchor" href="#aa1104---inner-types-must-be-private" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AA1104 - Inner Types Must Be Private</h4>

<p>Inner types should not be marked <code>internal</code> or <code>public</code> as this leads to leaky abstractions.</p>

<h3>
<a id="no-globalstatic-state" class="anchor" href="#no-globalstatic-state" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>No global/static state</h3>

<p>Global (and to a lesser extent, any static) state creates a testing and maintenance nightmare as code becomes both tightly coupled and tests must be run in sequence through fear that two tests might call two pieces of code that both modify shared state resulting in brittle tests. These rules prevent global and static state:</p>

<h4>
<a id="aa1200-do-not-use-static-fields" class="anchor" href="#aa1200-do-not-use-static-fields" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AA1200 Do Not Use Static Fields</h4>

<p>Static fields contain static scope and so should be avoided.</p>

<h4>
<a id="aa1201-do-not-use-static-properties" class="anchor" href="#aa1201-do-not-use-static-properties" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AA1201 Do Not Use Static Properties</h4>

<p>Static properties contain static scope and so should be avoided.</p>

<h3>
<a id="liskov-substitution-principle" class="anchor" href="#liskov-substitution-principle" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Liskov Substitution Principle</h3>

<p>From the <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov Substitution Principle</a> article on Wikipedia:</p>

<blockquote>
<p>Substitutability is a principle in object-oriented programming. It states that, in a computer program, if S is a subtype of T, then objects of type T may be replaced with objects of type S (i.e., objects of type S may substitute objects of type T) without altering any of the desirable properties of that program (correctness, task performed, etc.)</p>
</blockquote>

<p>Two exceptions defined by the .NET framework are a direct violation of this principle (LSP) and the following two rules check for such violations:</p>

<h4>
<a id="aa2000-do-not-use-notimplementedexception" class="anchor" href="#aa2000-do-not-use-notimplementedexception" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AA2000 Do Not Use NotImplementedException</h4>

<p>NotImplementedException violates LSP and should not be used.</p>

<h4>
<a id="aa2001-do-not-use-notsupportedexception" class="anchor" href="#aa2001-do-not-use-notsupportedexception" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AA2001 Do Not Use NotSupportedException</h4>

<p>NotSupportedException violates LSP and should not be used.</p>

<h3>
<a id="single-responsibility-principle" class="anchor" href="#single-responsibility-principle" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Single responsibility principle</h3>

<p>The <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">single responsibility principle</a> article on Wikipedia states:</p>

<blockquote>
<p>the single responsibility principle states that every class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class. All its services should be narrowly aligned with that responsibility</p>
</blockquote>

<p>The following rules extend this principle to methods and files and seek to identify sections of code that may break that principle:</p>

<h4>
<a id="aa2100-method-parameters-must-not-be-ref-or-out" class="anchor" href="#aa2100-method-parameters-must-not-be-ref-or-out" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AA2100 Method Parameters Must Not Be Ref Or Out</h4>

<p>Reports when either <code>ref</code> or <code>out</code> are used for any parameter of any method. Both of these keywords lead to a method that returns two results via two different routes, breaking the single responsibility principle.</p>

<h4>
<a id="aa2101-method-too-long" class="anchor" href="#aa2101-method-too-long" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AA2101 Method Too Long</h4>

<p>A long method is likely to break the principle by carrying out too many functions. What is too long is highly subjective, so this rule will need to be configurable to allow the maximum lines to be specified.</p>

<h4>
<a id="aa2102-file-too-long" class="anchor" href="#aa2102-file-too-long" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AA2102 File Too Long</h4>

<p>A long class is likely to break the principle by carrying out too many functions. What is too long is highly subjective, so this rule will need to be configurable to allow the maximum lines to be specified.</p>

<h4>
<a id="aa2103-method-should-not-contain-and" class="anchor" href="#aa2103-method-should-not-contain-and" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AA2103 Method Should Not Contain And</h4>

<p>Methods that contain "And" in their name often undertake two tasks and thus have two responsibilities. Thus they are likely to violate the principle.</p>

<h4>
<a id="aa2104-file-must-only-contain-one-type-definition" class="anchor" href="#aa2104-file-must-only-contain-one-type-definition" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>AA2104 File Must Only Contain One Type Definition</h4>

<p>A file that contains more than one class, enum or interface definition inherently contains more than one responsibility.  </p>

<a href="test.html">Test link 1</a>
<a href="test.md">Test link 2</a>

      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Arnolyzer maintained by <a href="https://github.com/DavidArno">DavidArno</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
